#[
    Just a bunch of useful math functions that I often use.
    
    ###################################
    ##            MathLib            ##
    ##      made by deltamolfar      ##
    ##        Glory to Ukraine       ##
    ###################################
    
    This chip can be freely distributed between anyone you want, as long, as you keep the author credits.
    If you change anything in this code, don't expect me to help you.
]#

# Is origin visible from cone (ignoring obstacles/world)
function number isInCone(Origin:vector, Target:vector, Normal:vector, ConeSpread:number){
    Normal = Normal:normalized()
    
    const AB = Target-Origin

    const Angle = acos(AB:dot(Normal)/(AB:length()*Normal:length()))
    
    if( Angle <= ConeSpread ){
        return 1
    } else{
        return 0
    }
}

# Swaps two number values in array. Returns new array (a bit slower)
function array array:swap_clone(IndexA:number, IndexB:number){
    const TempArr = This:clone()
    const TempInt = TempArr[IndexA, number]
    
    TempArr[IndexA, number] = TempArr[IndexB, number]
    TempArr[IndexB, number] = TempInt
    
    return TempArr
}

# Swaps two number values in array. Directly modifies an array (a bit faster)
function array:swap(IndexA:number, IndexB:number){
    const TempInt = This[IndexA, number]
    This[IndexA, number] = This[IndexB, number]
    This[IndexB, number] = TempInt
}

# Reverses an array. Directly modifies an array (a bit slower)
function array array:reverse_clone(){
    local Clone = This:clone()
    local ModifiedArray = This:clone()
    const Count = This:count()
    
    foreach(I:number, V:number = Clone){
        ModifiedArray[Count-(I-1), number] = V
    }
    
    return ModifiedArray
}

# Reverses an array. Directly modifies an array (a bit faster)
function array:reverse(){
    local Clone = This:clone()
    const Count = This:count()
    
    foreach(I:number, V:number = Clone){
        This[Count-(I-1), number] = V
    }
}

# Internal. For quickSort. Basically a sorting algorithm itself.
function table lib_internal_partition(Arr:array, Low:number, High:number){
    local ModifiedArray = Arr:clone()
    local Pivot = ModifiedArray[High, number]
    local I = Low-1
    
    local J = Low
    while(J<High){
        if( ModifiedArray[J, number]<Pivot ){
            I++
            ModifiedArray:swap(I, J)
        }
        J++
    }
    
    ModifiedArray:swap(I+1, High)
    
    return table(
        1 = ModifiedArray,
        2 = I+1
    )
}

# quickSort sorting. Returns new array.
function array quickSort(Arr:array, Low:number, High:number){
    if( Low<High ){
        const Partition = lib_internal_partition(Arr:clone(), Low, High)
        local ModifiedArray = Partition[1, array]
        local PivotIndex = Partition[2, number]
        
        ModifiedArray = quickSort(ModifiedArray, Low, PivotIndex-1)
        ModifiedArray = quickSort(ModifiedArray, PivotIndex+1, High)
        return ModifiedArray
    }
    
    return Arr:clone()
}

# Sorts an array containing numbers Ascendently. Returns new array.
function array array:sortArrayAsc(){
    return quickSort(This, 0, This:count())
}

# Sorts an array containing numbers Descendently. Returns new array.
function array array:sortArrayDesc(){
    const Arr = quickSort(This, 0, This:count())
    Arr:reverse()
    return Arr
}
